# Architecture Decision Record: Placement of Signature Verification Logic

## Status
Accepted

## Context
The application must verify that incoming JSON documents were correctly signed using an asymmetric cryptographic signature. These documents can arrive via various input channels, such as HTTP endpoints, Kafka messages, or file ingestion.

The key architectural question is: **Where should the signature verification logic reside within the layered or hexagonal architecture?**

## Decision
We decided to place the signature verification logic in the **application layer** using a reusable component called `SignatureVerifier`. This component is responsible for:

- Canonicalizing the payload (e.g., JSON serialization with consistent field order)
- Verifying the digital signature using a `PublicKeyResolver`
- Deserializing the payload into a type-safe domain command object

This solution aligns with the **Hexagonal Architecture (a.k.a. Ports and Adapters)** style. The signature verification logic serves as an application service (a port), while the concrete mechanism to retrieve the public key (e.g., from a file, keystore, or JWKS endpoint) is modeled as an adapter (via the `PublicKeyResolver` interface).

### Why not in the domain layer?
The domain layer should remain pure and agnostic of infrastructure and integration concerns. It must operate on already validated business objects (e.g., `Order`). Signature verification is a security/integration concern and does not belong in the domain.

### Why not in each adapter (e.g., HTTP, Kafka)?
Placing signature verification inside each primary adapter would lead to code duplication and increase the risk of inconsistent validation. Instead, adapters delegate the responsibility to the shared `SignatureVerifier`, ensuring consistency and testability.

### Application-layer benefits:
- Centralized verification logic
- Adapters are thin and reusable
- Easy to unit test without full-stack integration
- Decouples verification logic from specific transport mechanisms

## Consequences
- New input mechanisms (e.g., Kafka consumers or file readers) can reuse the same verification logic.
- Changes to the verification algorithm or canonicalization process require changes only in one place.
- Domain logic remains clean and focused solely on business rules.

## Related Code
- `SignatureVerifier.java`: Encapsulates signature validation and payload extraction
- `PublicKeyResolver.java`: Strategy for resolving public keys by key ID
- `OrderApplicationService.java`: Orchestrates verification + domain logic
